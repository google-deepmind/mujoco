# MuJoCo  Bindings

> [!IMPORTANT]
> These bindings are still a WIP, for details see the [Future Work](#future-work) section. Also
> be aware we have been developing these binding on Linux using Google Chrome. If you're working
> with a on a different OS or with a different browser then you may encounter some rough edges.

These are the canonical JavaScript/TypeScript bindings for the MuJoCo physics engine. These bindings are developed and maintained by Google DeepMind, and are kept up-to-date with the latest developments in MuJoCo. In the text below whenever we write JavaScript we also mean TypeScript. 

## Prerequisites

- In order to compile the `bindings.cc` file which generates the `.wasm` web-assembly file, `.js` JavaScript import and `.d.ts` TypeScript declaration file) you will need the Emscripten SDK version `4.0.10`. Later versions do not work yet, read [this](https://github.com/ekumenlabs/mujoco_internal/pull/44#issuecomment-3339343789) for more details. Download the SDK [here](https://emscripten.org/docs/getting_started/downloads.html) then follow these steps:

  ```sh
  git clone https://github.com/emscripten-core/emsdk.git
  cd emsdk
  ./emsdk install 4.0.10
  ./emsdk activate 4.0.10
  source ./emsdk_env.sh
  ```

- In order to easily run the JavaScript tests and the demo applications `node` and `npm` are required. We recommend managing this using [nvm](https://github.com/nvm-sh/nvm). There are also various JavaScript dependencies needed for the test suite, demo apps and bindings build process, these dependencies are currently expected to be installed in the `wasm` folder as follows:

  ```sh
  # Run this inside `wasm` folder
  npm install
  ```

- In order to modify the bindings `python3` is required since the `bindings.cc` file is (mostly) autogenerated with Python. In order to run the bindings generator tests `pytest` will also be helpful.


> [!TIP]
> Emscripten is well documentation we recommend reading the sections covering the [Emscripten Compiler Settings](https://emscripten.org/docs/tools_reference/settings_reference.html), the [Emscripten SDK](https://emscripten.org/docs/tools_reference/emsdk.html) and [Embind](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html). To understand the limitations/caveats related to using the browser as a platform read the relevant parts of the [porting](https://emscripten.org/docs/porting/index.html#porting) section.

## User Guide

### Bindings Generation

The following script will use MuJoCo's python introspect library to generate a C++ file with the relevant Embind `EMSCRIPTEN_BINDINGS` block which is used to bind C++ functions and classes to Javascript. The script generates wrapper functions around MuJoCo's C API which provide a place for adding conveniences like bounds checking.

```sh
# Run this inside `wasm` folder
PYTHONPATH=../python/mujoco:./codegen python3 codegen/update.py
```

Once the C++ files are generated (note that for convenience we provide the output of the above script in the `wasm/codegen/generated` folder already) the next step is to build the `.wasm`, `.js`, and `.d.ts` files from the C++ files (which are the files you will call MuJoCo from JavaScript). Make sure you have set up the npm and Emscripten SDK prequisites then run the following (in the same terminal session where `emsdk` environment was sourced):

> [!NOTE]
> Make sure to run the following steps in the same terminal session in which the Emscripen SDK was sourced, also make sure no `build` and `dist` folder exist in the root of the project or inside `wasm` folder.

```sh
# Run this inside `wasm` folder
WASM_DIR=$(pwd) && PROJECT_ROOT=$(dirname "$WASM_DIR") && \
export PATH="${WASM_DIR}/node_modules/.bin:$PATH" && \
emcmake cmake -S "$PROJECT_ROOT" -B "$PROJECT_ROOT/build" && \
cmake --build "$PROJECT_ROOT/build" && \
emcmake cmake -S "$WASM_DIR" -B "$WASM_DIR/build" && \
cmake --build "$WASM_DIR/build"
```

The above command will generate the following folders:

- `<project-root>/build` is the result of compiling MuJoCo with emscripten.
- `<project-root>/wasm/build` is the result of compiling MuJoCo bindings with emscripten.
- `<project-root>/wasm/dist` is MuJoCo WebAssembly module. To use it you need to import the `.js` file.


### Example Application

After generating the MuJoCo WASM module following the steps in the previous [section](#bindings-generation) you will be ready to write web applications using MuJoCo. We have provided a basic web application that uses ThreeJS to render a simple simulation.  To run the demo app use:

```sh
npm run dev:demo
```

> [!NOTE]
> Depending on your application you may find it easier to write your entire app in C++ and compile to WASM using emscripten. If you do this then you'll find that you don't need to use these bindings since you will be writing very minimal JavaScript e.g., you can set the `requestAnimationFrame` callback directly from C++ using this [macro]().  We have also found that a hybrid approach can be helpful because it's more convenient to work with browser APIs directly in JavaScript, where most of the app is written in C++ and compiled using emscripten but then a small subset of the `EMSCRIPTEN_BINDINGS` block is copied from `bindings.cc` and pasted into the application source. file is 

## Development

### Tests

There are two three of tests:

1. JavaScript API tests. verifies a wide variety of MuJoCo functions and classes work correctly when called from Javascript, there are also some preliminary benchmarks for shared memory buffers.  Run the following commands (the benchmark bindings code is compilied first):

   ```sh
   # Run this inside `wasm` folder
   WASM_DIR=$(pwd) && \
   export PATH="${WASM_DIR}/node_modules/.bin:$PATH" && \
   emcmake cmake -S "$WASM_DIR/tests" -B "$WASM_DIR/tests/build" && \
   cmake --build "$WASM_DIR/tests/build" && \
   npm run test
   ```

2. JS/TS sandbox test app. Use `npm run dev:sandbox`. This is a playground app meant for you to experiment any MuJoCo functionality you want in the browser.

3. Bindings Generator tests. These are relevant when developing/extending the bindings. The enums test is special since its auto-generated to cover all enums in the API.

   ```sh
   # Run this inside `wasm` folder
   PYTHONPATH=../python/mujoco:../wasm python3 tests/enums_test_generator.py && \

   # Runs files of the form test_*.py or *_test.py in the current directory recursively
   PYTHONPATH=../python/mujoco:./codegen python3 -m pytest
   ```

### Debugging

It is possible to set up a pretty nice debugging workflow using Chrome DevTools where stack traces and stepping through code work nicely across language boundaries. Our current tools work within Google but it should be possible to replicate the experience with open source. Community suggestions in this direction are welcome!


## Future Work

1. _Bind all useful APIs_. These bindings are not yet complete. While the main MuJoCo APIs (`mj_step`, `mj_loadXML` etc) are well tested, other APIs (e.g., functions from `mjspec.h`) are untested in real web applications (test code for the mjspec bindings do exist). One notable feature not yet supported in the WASM bindings, which has proved to be very useful in the Python bindings, is named access methods where data which is distributed across multiple arrays in C can be conventiently accessed using the element name e.g., `model.geom('mygeom')` to access data related to `mygeom` and `data.joint('myjoint')` to access data related to `myjoint`. Currently in the WASM bindings this data needs to be accessed via the `mj_name2id` function. Adding support for these features is a high priority since it affects the user code written in JavaScript.

2. _Improve the developer experience_. There is also more work to do to improve the developer experience when developing the WASM bindings. The most obvious issue is that bindings generation is not fully automated. A consequence of this is that its currently less convenient than we'd like to understand the change that needs to be made to update the bindings. The goal is to eventually automatically generate all the binding code and clearly communicate what changes that need to be made in the WASM bindings as a consequence of C++ changes. This problem should only affect people developing MuJoCo engine code in C++, not users writing JavaScript. 

3. _Improve the documentation_. The documentation in this readme will eventually be merged into the main MuJoCo docs. This will happen after the bindings are complete and the named access is implemented. We also intend to make a pass over the bindings APIs and make changes to minimize the differences with the Python bindings (while accounting for the language idioms) to minize the amount of additional documentation required.

4. _Improve the [example](#example-application)_. We would like to provide an example application which can be easily be modified and embedded into a paper project page (see [this example](https://kzakka.com/robopianist/). This could be done by extending the THREE.js example, or, alternatively by compiling the MuJoCo toolbox C++ code using the Emscripten toolchain. Community suggestions/contributions welcome!

