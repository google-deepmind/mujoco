# MuJoCo JavaScript Bindings

These are the canonical JavaScript and TypeScript bindings for the MuJoCo physics engine.

This package provides a high-level API that allows you to interact with the core MuJoCo engine compiled into a high-performance WebAssembly (WASM) module. These bindings are developed and maintained by Google DeepMind and are always up to date with the latest developments in MuJoCo. For brevity, the documentation below will often refer to “JavaScript” but the concepts apply equally to TypeScript.

> [!IMPORTANT]
> _These bindings are still a WIP. For details, see the [Future Work](#future-work) section.
> Also note that development has primarily taken place on Linux using Google Chrome.
> If you’re working on a different OS or browser, you may encounter some rough edges._

## Prerequisites

- To compile the [`bindings.cc`](codegen/generated/bindings.cc) file, which generates the `.wasm` WebAssembly file, `.js` JavaScript import, and `.d.ts` TypeScript declaration file, you will need Emscripten SDK version `4.0.10`. Later versions may work but are untested. To set up the SDK, do the following:

  ```sh
  git clone https://github.com/emscripten-core/emsdk.git
  cd emsdk
  ./emsdk install 4.0.10
  ./emsdk activate 4.0.10
  source ./emsdk_env.sh
  ```

- To easily run the JavaScript tests and the demo application, `node` and `npm` are required.
  We recommend managing these using [nvm](https://github.com/nvm-sh/nvm).
  There are also various JavaScript dependencies needed for the tests, demo, and bindings build process.
  These dependencies are expected to be located in the `wasm` folder. To install them, run:

  ```sh
  # Run this inside the `wasm` folder
  npm install
  ```

- To modify the bindings, `python3` is required since the [`bindings.cc`](codegen/generated/bindings.cc) file is generated by a Python script. To run the bindings generator tests, `pytest` will also be helpful.

> [!TIP]
> _Emscripten is well-documented. We recommend reading the sections covering the
> [Emscripten Compiler Settings](https://emscripten.org/docs/tools_reference/settings_reference.html),
> the [Emscripten SDK](https://emscripten.org/docs/tools_reference/emsdk.html), and the
> [Embind](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html) library.
> To understand the limitations and caveats related to using the browser as a platform, see the
> [Porting](https://emscripten.org/docs/porting/index.html#porting) section._

## User Guide

### Bindings Generation

The following script uses MuJoCo’s Python introspect library to generate a C++ file containing the relevant Embind `EMSCRIPTEN_BINDINGS` block, which is used to bind C++ functions and classes to JavaScript. The script generates wrapper functions around MuJoCo’s C API that provide a place to add conveniences such as bounds checking.

```sh
# Run this inside the `wasm` folder
PYTHONPATH=../python/mujoco:./codegen python3 codegen/update.py
```

Once the C++ files are generated (note that, for convenience, we already provide the output of the above script in the [`generated`](codegen/generated) folder), the next step is to build the `.wasm`, `.js`, and `.d.ts` files from the C++ sources (which are the files you will use to call MuJoCo from JavaScript). Make sure you have set up npm and the Emscripten SDK prerequisites, then run the following in the same terminal session where the `emsdk` environment was sourced:

```sh
# Run this inside the `wasm` folder
WASM_DIR=$(pwd) && PROJECT_ROOT=$(dirname "$WASM_DIR") && \
export PATH="${WASM_DIR}/node_modules/.bin:$PATH" && \
emcmake cmake -S "$PROJECT_ROOT" -B "$PROJECT_ROOT/build" && \
cmake --build "$PROJECT_ROOT/build" && \
emcmake cmake -S "$WASM_DIR" -B "$WASM_DIR/build" && \
cmake --build "$WASM_DIR/build"
```

The above command will generate the following folders:

- `<project-root>/build`: the result of compiling MuJoCo with Emscripten.
- `<project-root>/wasm/build`: the result of compiling the MuJoCo bindings with Emscripten.
- `<project-root>/wasm/dist`: the MuJoCo WebAssembly module. To use it, import the `.js` file.

### Example Application

After generating the MuJoCo WASM module following the steps in the previous [section](#bindings-generation), you will be ready to write web applications using MuJoCo.
We have provided a basic web application that uses Three.js to render a simple simulation. To run the demo app, use:

```sh
npm run dev:demo
```

You may prefer to write your entire app in C++ and compile it using Emscripten. If you do this, you won’t need to use these bindings, since you’ll be writing minimal JavaScript, and the granularity of these bindings may be inappropriate (e.g., you might want to call multiple MuJoCo functions in the C++ callback invoked by `requestAnimationFrame`).

We have also found that a hybrid approach can be helpful, as it is often more convenient to work with browser APIs directly in JavaScript.
If you choose to write your application in C++ and compile it using Emscripten, you may want to copy a subset of the `EMSCRIPTEN_BINDINGS` from `bindings.cc` into your application’s source file.

## Development

### Testing

1. **JavaScript API tests.**
   These verify that a wide variety of MuJoCo functions and classes work correctly when called from JavaScript.
   There are also preliminary benchmarks for shared memory buffers. Run the following commands (the benchmark bindings code is compiled first):

   ```sh
   # Run this inside the `wasm` folder
   WASM_DIR=$(pwd) && \
   export PATH="${WASM_DIR}/node_modules/.bin:$PATH" && \
   emcmake cmake -S "$WASM_DIR/tests" -B "$WASM_DIR/tests/build" && \
   cmake --build "$WASM_DIR/tests/build" && \
   npm run test
   ```

2. **Bindings generator tests.**
   These are relevant when developing or extending the bindings. The enums test is special since it is auto-generated to cover all enums in the API.

   ```sh
   # Run this inside the `wasm` folder
   PYTHONPATH=../python/mujoco:../wasm python3 tests/enums_test_generator.py && \

   # Runs files of the form test_*.py or *_test.py in the current directory recursively
   PYTHONPATH=../python/mujoco:./codegen python3 -m pytest
   ```

### Debugging

We provide a “sandbox” app where you can quickly write code to run in your browser.
Write your code in the [`main.ts`](tests/sandbox/main.ts) file and use the following command to execute it in your browser:

```sh
npm run dev:sandbox
```

You can log to the console and use Chrome DevTools for debugging.
It is possible to set up a debug workflow where stack traces and stepping through code across language boundaries work correctly.
Our current method to do this only works internally at Google, but it should be possible to replicate the experience with open-source tooling — community suggestions are welcome!

## Future Work

1. **Bind all useful APIs.**
   These bindings are not yet complete. While the main MuJoCo APIs (`mj_step`, `mj_loadXML`, etc.) are well tested, other APIs (e.g., functions from `mjspec.h`) remain untested in real web applications (though test code for the `mjspec` bindings does exist).
   One notable feature not yet supported in the WASM bindings, which has proved very useful in the Python bindings, is named access methods — where data distributed across multiple arrays in C can be conveniently accessed by name, e.g., `model.geom('mygeom')` or `data.joint('myjoint')`.
   Currently, this data must be accessed via the `mj_name2id` function.
   Adding support for these features is a high priority, as it affects user code written in JavaScript.

2. **Improve the developer experience.**
   There is still work to be done to improve the developer experience when developing the WASM bindings.
   The most obvious issue is that bindings generation is not yet fully automated.
   As a result, it is currently less convenient than we’d like to identify and apply the changes needed to update the bindings.
   The goal is to eventually automate all binding code generation and clearly communicate what changes are required in the WASM bindings as a result of C++ updates.
   This problem should only affect developers working on the MuJoCo engine in C++, not end users writing JavaScript.

3. **Improve the documentation.**
   The documentation in this README will eventually be merged into the main MuJoCo documentation once the bindings are complete and named access is implemented.
   We also intend to review the bindings APIs and make adjustments to minimize differences with the Python bindings (while respecting language idioms) to reduce the amount of additional documentation required.

4. **Improve the [example](#example-application).**
   We aim to provide an example application that can be easily modified and embedded into a paper project page (see [this example](https://kzakka.com/robopianist/)).
   This could be achieved by extending the Three.js example or by compiling the MuJoCo toolbox C++ code using the Emscripten toolchain.
   Community suggestions and contributions are welcome!
