#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class "SceneAPI" (
    doc = "API providing global simulation options for Mujoco."
)
{
    uniform bool mjc:flag:actuation = 1 (
        displayName = "Actuation Forces Toggle"
        doc = "Enables all standard computations related to actuator forces, including actuator dynamics."
    )
    uniform bool mjc:flag:autoreset = 1 (
        displayName = "Automatic Simulation Reset Toggle"
        doc = "Enables the automatic resetting of the simulation state when numerical issues are detected."
    )
    uniform bool mjc:flag:clampctrl = 1 (
        displayName = "Control Input Clamping Toggle"
        doc = "Enables the clamping of control inputs to all actuators, according to actuator-specific attributes."
    )
    uniform bool mjc:flag:constraint = 1 (
        displayName = "Constraint Solver Toggle"
        doc = "Enables constraint solver."
    )
    uniform bool mjc:flag:contact = 1 (
        displayName = "Contact Constraints and Collision Detection Toggle"
        doc = "Enables collision detection and all standard computations related to contact constraints."
    )
    uniform bool mjc:flag:energy = 0 (
        displayName = "Energy Computation Toggle"
        doc = "Enables the computation of potential and kinetic energy (mjData.energy[0,1])."
    )
    uniform bool mjc:flag:equality = 1 (
        displayName = "Equality Constraints Toggle"
        doc = "Enables all standard computations related to equality constraints."
    )
    uniform bool mjc:flag:eulerdamp = 1 (
        displayName = "Euler Integrator Damping Toggle"
        doc = "Enables implicit integration with respect to joint damping in the Euler integrator."
    )
    uniform bool mjc:flag:filterparent = 1 (
        displayName = "Parent-Child Contact Filtering Toggle"
        doc = "Enables the filtering of contact pairs where the two geoms belong to a parent and child body."
    )
    uniform bool mjc:flag:frictionloss = 1 (
        displayName = "Friction Loss Constraints Toggle"
        doc = "Enables all standard computations related to friction loss constraints."
    )
    uniform bool mjc:flag:fwdinv = 0 (
        displayName = "Forward/Inverse Dynamics Comparison Toggle"
        doc = "Enables the automatic comparison of forward and inverse dynamics."
    )
    uniform bool mjc:flag:gravity = 1 (
        displayName = "Gravity Toggle"
        doc = "Enables the application of gravitational acceleration as defined in mjOption."
    )
    uniform bool mjc:flag:invdiscrete = 0 (
        displayName = "Discrete-Time Inverse Dynamics Toggle"
        doc = "Enables discrete-time inverse dynamics with mj_inverse for integrators other than RK4."
    )
    uniform bool mjc:flag:island = 0 (
        displayName = "Constraint Island Discovery Toggle"
        doc = "Enables the discovery of constraint islands."
    )
    uniform bool mjc:flag:limit = 1 (
        displayName = "Joint and Tendon Limit Constraints Toggle"
        doc = "Enables all standard computations related to joint and tendon limit constraints."
    )
    uniform bool mjc:flag:midphase = 1 (
        displayName = "Mid-Phase Collision Filtering Toggle"
        doc = "Enables mid-phase collision filtering using a static AABB bounding volume hierarchy (BVH)."
    )
    uniform bool mjc:flag:multiccd = 0 (
        displayName = "Multiple Contact Collision Detection (CCD) Toggle"
        doc = "Enables multiple-contact collision detection for geom pairs using a general-purpose convex-convex collider."
    )
    uniform bool mjc:flag:nativeccd = 1 (
        displayName = "Native Convex Collision Detection Toggle"
        doc = "Enables the native convex collision detection pipeline instead of using the libccd library."
    )
    uniform bool mjc:flag:override = 0 (
        displayName = "Contact Override Mechanism Toggle"
        doc = "Enables the contact override mechanism."
    )
    uniform bool mjc:flag:passive = 1 (
        displayName = "Passive Forces Toggle"
        doc = "Enables the simulation of joint and tendon spring-dampers, fluid dynamics forces, and custom passive forces."
    )
    uniform bool mjc:flag:refsafe = 1 (
        displayName = "Solver Reference Safety Mechanism Toggle"
        doc = "Enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep."
    )
    uniform bool mjc:flag:sensor = 1 (
        displayName = "Sensor Computations Toggle"
        doc = "Enables all computations related to sensors."
    )
    uniform bool mjc:flag:warmstart = 1 (
        displayName = "Solver Warm-Starting Toggle"
        doc = "Enables warm-starting of the constraint solver, using the solution from the previous time step to initialize the iterative optimization."
    )
    uniform int[] mjc:option:actuatorgroupdisable (
        displayName = "Actuator Group Disable"
        doc = "List of actuator groups to disable."
    )
    uniform double mjc:option:apirate = 100 (
        displayName = "ApiRate"
        doc = """Determines the rate (in Hz) at which an external API allows
        the update function to be executed."""
    )
    uniform int mjc:option:ccd_iterations = 50 (
        displayName = "CCD Iterations"
        doc = "Maximum number of iterations of the algorithm used for convex collisions."
    )
    uniform double mjc:option:ccd_tolerance = 0.000001 (
        displayName = "CCD Tolerance"
        doc = """Tolerance threshold used for early termination of the convex
        collision algorithm."""
    )
    uniform token mjc:option:cone = "pyramidal" (
        allowedTokens = ["pyramidal", "elliptic"]
        displayName = "Friction Cone Type"
        doc = "The type of contact friction cone."
    )
    uniform double mjc:option:density = 0 (
        displayName = "Density"
        doc = "Density of medium."
    )
    uniform double mjc:option:impratio = 1 (
        displayName = "Impedance Ratio"
        doc = """Ratio of frictional-to-normal constraint impedance for elliptic
        friction cones."""
    )
    uniform token mjc:option:integrator = "euler" (
        allowedTokens = ["euler", "rk4", "implicit", "implicitfast"]
        displayName = "Integrator"
        doc = "Numerical integrator to be used."
    )
    uniform int mjc:option:iterations = 100 (
        displayName = "Solver Iterations"
        doc = "Maximum number of iterations of the constraint solver."
    )
    uniform token mjc:option:jacobian = "auto" (
        allowedTokens = ["auto", "dense", "sparse"]
        displayName = "Jacobian Type"
        doc = "The type of constraint Jacobian and matrices computed from it."
    )
    uniform int mjc:option:ls_iterations = 50 (
        displayName = "Linesearch Iterations"
        doc = """Maximum number of linesearch iterations performed by CG/Newton
        constraint solvers."""
    )
    uniform double mjc:option:ls_tolerance = 0.01 (
        displayName = "Linesearch Tolerance"
        doc = "Tolerance threshold used for early termination of the linesearch algorithm."
    )
    uniform double3 mjc:option:magnetic = (0, -0.5, 0) (
        displayName = "Magnetic Flux"
        doc = "Global magnetic flux."
    )
    uniform int mjc:option:noslip_iterations = 0 (
        displayName = "Noslip Iterations"
        doc = "Maximum number of iterations of the Noslip solver."
    )
    uniform double mjc:option:noslip_tolerance = 0.000001 (
        displayName = "Noslip Tolerance"
        doc = "Tolerance threshold used for early termination of the Noslip solver."
    )
    uniform double[] mjc:option:o_friction = [1, 1, 0.005, 0.0001, 0.0001] (
        displayName = "Contact Override Friction"
        doc = """Replaces the friction parameter of all active contact pairs when
        Contact override is enabled."""
    )
    uniform double mjc:option:o_margin = 0 (
        displayName = "Contact Override Margin"
        doc = """Replaces the margin parameter of all active contact pairs when
        Contact override is enabled."""
    )
    uniform double[] mjc:option:o_solimp = [0.9, 0.95, 0.001, 0.5, 2] (
        displayName = "Contact Override SolImp"
        doc = """Replaces the solimp parameter of all active contact pairs when
        Contact override is enabled."""
    )
    uniform double[] mjc:option:o_solref = [0.02, 1] (
        displayName = "Contact Override SolRef"
        doc = """Replaces the solref parameter of all active contact pairs when
        Contact override is enabled."""
    )
    uniform int mjc:option:sdf_initpoints = 40 (
        displayName = "SDF Initial Points"
        doc = """Number of starting points used for finding contacts with Signed
        Distance Field collisions."""
    )
    uniform int mjc:option:sdf_iterations = 10 (
        displayName = "SDF Iterations"
        doc = """Number of iterations used for Signed Distance Field collisions
        (per initial point)."""
    )
    uniform token mjc:option:solver = "newton" (
        allowedTokens = ["pgs", "cg", "newton"]
        displayName = "Solver"
        doc = "Constraint solver algorithm to be used."
    )
    uniform double mjc:option:timestep = 0.002 (
        displayName = "Timestep"
        doc = "Controls the timestep in seconds used by MuJoCo."
    )
    uniform double mjc:option:tolerance = 1e-8 (
        displayName = "Solver Tolerance"
        doc = """Tolerance threshold used for early termination of the iterative
        solver."""
    )
    uniform double mjc:option:viscosity = 0 (
        displayName = "Viscosity"
        doc = "Viscosity of medium."
    )
    uniform double3 mjc:option:wind = (0, 0, 0) (
        displayName = "Wind Velocity"
        doc = "Velocity vector of medium (i.e. wind)."
    )
}

class "SiteAPI" (
    doc = "API describing a Mujoco site."
)
{
}

class "CollisionAPI" (
    doc = "API describing a Mujoco collider."
)
{
    uniform bool mjc:shellinertia = 0 (
        displayName = "Shell Inertia"
        doc = "Enables handling of the inertia assuming mass is concentrated on the surface."
    )
}

class "MeshCollisionAPI" (
    doc = "API describing a Mujoco collider."
)
{
    uniform token mjc:inertia = "legacy" (
        allowedTokens = ["legacy", "convex", "exact", "shell"]
        displayName = "Inertia"
        doc = "Controls how a mesh is used when mass and inertia are inferred from geometry."
    )
}

class "PhysicsActuatorAPI" (
    doc = "API describing a Mujoco actuator."
)
{
    uniform int mjc:actDim = -1 (
        doc = "Dimension of the activation state. The default value of -1 instructs the compiler to set the dimension according to the dyntype. Values larger than 1 are only allowed for user-defined activation dynamics, as native types require dimensions of only 0 or 1. For activation dimensions bigger than 1, the last element is used to generate force."
    )
    uniform bool mjc:actEarly = 0 (
        doc = "If true, force computation will use the next value of the activation variable rather than the current one. Setting this flag reduces the delay between the control and accelerations by one time-step."
    )
    uniform token mjc:actLimited = "auto" (
        allowedTokens = ["false", "true", "auto"]
        doc = "If true, the internal state (activation) associated with this actuator is automatically clamped to actrange at runtime. If false, activation clamping is disabled. If 'auto' and autolimits is set in compiler, activation clamping will automatically be set to true if actrange is defined without explicitly setting this attribute to 'true'. See the Activation clamping section for more details."
    )
    uniform double mjc:actRange:max = 0 (
        doc = "Maximum range for clamping the activation state. The first value must be no greater than the second value. See the Activation clamping section for more details. Setting this attribute without specifying actlimited is an error if autolimits is 'false' in compiler."
    )
    uniform double mjc:actRange:min = 0 (
        doc = "Minimum range for clamping the activation state. The first value must be no greater than the second value. See the Activation clamping section for more details. Setting this attribute without specifying actlimited is an error if autolimits is 'false' in compiler."
    )
    uniform double[] mjc:biasPrm = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] (
        doc = "Bias parameters. The affine bias type uses three parameters. The length of this array is not enforced by the parser, so the user can enter as many parameters as needed. These defaults are not compatible with muscle actuators."
    )
    uniform token mjc:biasType = "none" (
        allowedTokens = ["none", "affine", "muscle", "user"]
        doc = "The gain and bias together determine the output of the force generation mechanism, which is currently assumed to be affine."
    )
    uniform double mjc:crankLength = 0 (
        doc = "Used only for the slider-crank transmission type. Specifies the length of the connecting rod. The compiler expects this value to be positive when a slider-crank transmission is present."
    )
    rel mjc:crankSite (
        doc = "If specified, the actuator acts on a slider-crank mechanism which is implicitly determined by the actuator (i.e., it is not a separate model element). The target site corresponds to the pin joining the crank and the connecting rod."
    )
    uniform token mjc:ctrlLimited = "auto" (
        allowedTokens = ["false", "true", "auto"]
        doc = "If true, the control input to this actuator is automatically clamped to ctrlrange at runtime. If false, control input clamping is disabled. If 'auto' and autolimits is set in compiler, control clamping will automatically be set to true if ctrlrange is defined without explicitly setting this attribute to 'true'. Note that control input clamping can also be globally disabled with the clampctrl attribute of option/flag."
    )
    uniform double mjc:ctrlRange:max = 0 (
        doc = "Maximum range for clamping the control input. The first value must be smaller than the second value. Setting this attribute without specifying ctrllimited is an error if autolimits is 'false' in compiler."
    )
    uniform double mjc:ctrlRange:min = 0 (
        doc = "Minimum range for clamping the control input. The first value must be smaller than the second value. Setting this attribute without specifying ctrllimited is an error if autolimits is 'false' in compiler."
    )
    uniform double[] mjc:dynPrm = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] (
        doc = "Activation dynamics parameters. The built-in activation types (except for muscle) use only the first parameter, but we provide additional parameters in case user callbacks implement a more elaborate model. The length of this array is not enforced by the parser, so the user can enter as many parameters as needed. These defaults are not compatible with muscle actuators."
    )
    uniform token mjc:dynType = "none" (
        allowedTokens = ["none", "integrator", "filter", "filterexact", "muscle", "user"]
        doc = "Activation dynamics type for the actuator. The available dynamics types were already described in the Actuation model section."
    )
    uniform token mjc:forceLimited = "auto" (
        allowedTokens = ["false", "true", "auto"]
        doc = "If true, the force output of this actuator is automatically clamped to forcerange at runtime. If false, force clamping is disabled. If 'auto' and autolimits is set in compiler, force clamping will automatically be set to true if forcerange is defined without explicitly setting this attribute to 'true'."
    )
    uniform double mjc:forceRange:max = 0 (
        doc = "Maximum range for clamping the force output. The first value must be no greater than the second value. Setting this attribute without specifying forcelimited is an error if autolimits is 'false' in compiler."
    )
    uniform double mjc:forceRange:min = 0 (
        doc = "Minimum range for clamping the force output. The first value must be no greater than the second value. Setting this attribute without specifying forcelimited is an error if autolimits is 'false' in compiler."
    )
    uniform double[] mjc:gainPrm = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] (
        doc = "Gain parameters. The built-in gain types (except for muscle) use only the first parameter, but we provide additional parameters in case user callbacks implement a more elaborate model. The length of this array is not enforced by the parser, so the user can enter as many parameters as needed. These defaults are not compatible with muscle actuators."
    )
    uniform token mjc:gainType = "fixed" (
        allowedTokens = ["fixed", "affine", "muscle", "user"]
        doc = "The gain and bias together determine the output of the force generation mechanism, which is currently assumed to be affine."
    )
    uniform double[] mjc:gear = [1, 0, 0, 0, 0, 0] (
        doc = "This attribute scales the length (and consequently moment arms, velocity and force) of the actuator, for all transmission types. It is different from the gain in the force generation mechanism, because the gain only scales the force output and does not affect the length, moment arms and velocity. For actuators with scalar transmission, only the first element of this vector is used. The remaining elements are needed for joint, jointinparent and site transmissions where this attribute is used to specify 3D force and torque axes."
    )
    uniform bool mjc:jointInParent = 0 (
        doc = "If true and applied to ball and free joints, the 3d rotation axis given by gear is defined in the parent frame (which is the world frame for free joints) rather than the child frame."
    )
    uniform double mjc:lengthRange:max = 0 (
        doc = "Maximum range of feasible lengths of the actuator’s transmission."
    )
    uniform double mjc:lengthRange:min = 0 (
        doc = "Minimum range of feasible lengths of the actuator’s transmission."
    )
    rel mjc:refSite (
        doc = "When applied to a site, measure the translation and rotation w.r.t the frame of the refsite. In this case the actuator does have length and position actuators can be used to directly control an end effector, see refsite.xml example model. As above, the length is the dot product of the gear vector and the frame difference. So gear='0 1 0 0 0 0' means 'Y-offset of site in the refsite frame', while gear='0 0 0 0 0 1' means rotation 'Z- rotation of site in the refsite frame'. It is recommended to use a normalized gear vector with nonzeros in only the first 3 or the last 3 elements of gear, so the actuator length will be in either length units or radians, respectively. As with ball joints (see joint above), for rotations which exceed a total angle of pi will wrap around, so tighter limits are recommended."
    )
    rel mjc:sliderSite (
        doc = "Used only for the slider-crank transmission type. The target site is the pin joining the slider and the connecting rod. The slider moves along the z-axis of the slidersite frame. Therefore the site should be oriented as needed when it is defined in the kinematic tree; its orientation cannot be changed in the actuator definition."
    )
}

