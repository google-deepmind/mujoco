#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class "SceneAPI" (
    doc = "API providing global simulation options for Mujoco."
)
{
    uniform bool mjc:flag:actuation = 1 (
        displayName = "Actuation Forces Toggle"
        doc = "Enables all standard computations related to actuator forces, including actuator dynamics."
    )
    uniform bool mjc:flag:autoreset = 1 (
        displayName = "Automatic Simulation Reset Toggle"
        doc = "Enables the automatic resetting of the simulation state when numerical issues are detected."
    )
    uniform bool mjc:flag:clampctrl = 1 (
        displayName = "Control Input Clamping Toggle"
        doc = "Enables the clamping of control inputs to all actuators, according to actuator-specific attributes."
    )
    uniform bool mjc:flag:constraint = 1 (
        displayName = "Constraint Solver Toggle"
        doc = "Enables constraint solver."
    )
    uniform bool mjc:flag:contact = 1 (
        displayName = "Contact Constraints and Collision Detection Toggle"
        doc = "Enables collision detection and all standard computations related to contact constraints."
    )
    uniform bool mjc:flag:energy = 0 (
        displayName = "Energy Computation Toggle"
        doc = "Enables the computation of potential and kinetic energy (mjData.energy[0,1])."
    )
    uniform bool mjc:flag:equality = 1 (
        displayName = "Equality Constraints Toggle"
        doc = "Enables all standard computations related to equality constraints."
    )
    uniform bool mjc:flag:eulerdamp = 1 (
        displayName = "Euler Integrator Damping Toggle"
        doc = "Enables implicit integration with respect to joint damping in the Euler integrator."
    )
    uniform bool mjc:flag:filterparent = 1 (
        displayName = "Parent-Child Contact Filtering Toggle"
        doc = "Enables the filtering of contact pairs where the two geoms belong to a parent and child body."
    )
    uniform bool mjc:flag:frictionloss = 1 (
        displayName = "Friction Loss Constraints Toggle"
        doc = "Enables all standard computations related to friction loss constraints."
    )
    uniform bool mjc:flag:fwdinv = 0 (
        displayName = "Forward/Inverse Dynamics Comparison Toggle"
        doc = "Enables the automatic comparison of forward and inverse dynamics."
    )
    uniform bool mjc:flag:gravity = 1 (
        displayName = "Gravity Toggle"
        doc = "Enables the application of gravitational acceleration as defined in mjOption."
    )
    uniform bool mjc:flag:invdiscrete = 0 (
        displayName = "Discrete-Time Inverse Dynamics Toggle"
        doc = "Enables discrete-time inverse dynamics with mj_inverse for integrators other than RK4."
    )
    uniform bool mjc:flag:island = 0 (
        displayName = "Constraint Island Discovery Toggle"
        doc = "Enables the discovery of constraint islands."
    )
    uniform bool mjc:flag:limit = 1 (
        displayName = "Joint and Tendon Limit Constraints Toggle"
        doc = "Enables all standard computations related to joint and tendon limit constraints."
    )
    uniform bool mjc:flag:midphase = 1 (
        displayName = "Mid-Phase Collision Filtering Toggle"
        doc = "Enables mid-phase collision filtering using a static AABB bounding volume hierarchy (BVH)."
    )
    uniform bool mjc:flag:multiccd = 0 (
        displayName = "Multiple Contact Collision Detection (CCD) Toggle"
        doc = "Enables multiple-contact collision detection for geom pairs using a general-purpose convex-convex collider."
    )
    uniform bool mjc:flag:nativeccd = 1 (
        displayName = "Native Convex Collision Detection Toggle"
        doc = "Enables the native convex collision detection pipeline instead of using the libccd library."
    )
    uniform bool mjc:flag:override = 0 (
        displayName = "Contact Override Mechanism Toggle"
        doc = "Enables the contact override mechanism."
    )
    uniform bool mjc:flag:passive = 1 (
        displayName = "Passive Forces Toggle"
        doc = "Enables the simulation of joint and tendon spring-dampers, fluid dynamics forces, and custom passive forces."
    )
    uniform bool mjc:flag:refsafe = 1 (
        displayName = "Solver Reference Safety Mechanism Toggle"
        doc = "Enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep."
    )
    uniform bool mjc:flag:sensor = 1 (
        displayName = "Sensor Computations Toggle"
        doc = "Enables all computations related to sensors."
    )
    uniform bool mjc:flag:warmstart = 1 (
        displayName = "Solver Warm-Starting Toggle"
        doc = "Enables warm-starting of the constraint solver, using the solution from the previous time step to initialize the iterative optimization."
    )
    uniform int[] mjc:option:actuatorgroupdisable (
        displayName = "Actuator Group Disable"
        doc = "List of actuator groups to disable."
    )
    uniform double mjc:option:apirate = 100 (
        displayName = "ApiRate"
        doc = """Determines the rate (in Hz) at which an external API allows
        the update function to be executed."""
    )
    uniform int mjc:option:ccd_iterations = 50 (
        displayName = "CCD Iterations"
        doc = "Maximum number of iterations of the algorithm used for convex collisions."
    )
    uniform double mjc:option:ccd_tolerance = 0.000001 (
        displayName = "CCD Tolerance"
        doc = """Tolerance threshold used for early termination of the convex
        collision algorithm."""
    )
    uniform token mjc:option:cone = "pyramidal" (
        allowedTokens = ["pyramidal", "elliptic"]
        displayName = "Friction Cone Type"
        doc = "The type of contact friction cone."
    )
    uniform double mjc:option:density = 0 (
        displayName = "Density"
        doc = "Density of medium."
    )
    uniform double mjc:option:impratio = 1 (
        displayName = "Impedance Ratio"
        doc = """Ratio of frictional-to-normal constraint impedance for elliptic
        friction cones."""
    )
    uniform token mjc:option:integrator = "euler" (
        allowedTokens = ["euler", "rk4", "implicit", "implicitfast"]
        displayName = "Integrator"
        doc = "Numerical integrator to be used."
    )
    uniform int mjc:option:iterations = 100 (
        displayName = "Solver Iterations"
        doc = "Maximum number of iterations of the constraint solver."
    )
    uniform token mjc:option:jacobian = "auto" (
        allowedTokens = ["auto", "dense", "sparse"]
        displayName = "Jacobian Type"
        doc = "The type of constraint Jacobian and matrices computed from it."
    )
    uniform int mjc:option:ls_iterations = 50 (
        displayName = "Linesearch Iterations"
        doc = """Maximum number of linesearch iterations performed by CG/Newton
        constraint solvers."""
    )
    uniform double mjc:option:ls_tolerance = 0.01 (
        displayName = "Linesearch Tolerance"
        doc = "Tolerance threshold used for early termination of the linesearch algorithm."
    )
    uniform double3 mjc:option:magnetic = (0, -0.5, 0) (
        displayName = "Magnetic Flux"
        doc = "Global magnetic flux."
    )
    uniform int mjc:option:noslip_iterations = 0 (
        displayName = "Noslip Iterations"
        doc = "Maximum number of iterations of the Noslip solver."
    )
    uniform double mjc:option:noslip_tolerance = 0.000001 (
        displayName = "Noslip Tolerance"
        doc = "Tolerance threshold used for early termination of the Noslip solver."
    )
    uniform double[] mjc:option:o_friction = [1, 1, 0.005, 0.0001, 0.0001] (
        displayName = "Contact Override Friction"
        doc = """Replaces the friction parameter of all active contact pairs when
        Contact override is enabled."""
    )
    uniform double mjc:option:o_margin = 0 (
        displayName = "Contact Override Margin"
        doc = """Replaces the margin parameter of all active contact pairs when
        Contact override is enabled."""
    )
    uniform double[] mjc:option:o_solimp = [0.9, 0.95, 0.001, 0.5, 2] (
        displayName = "Contact Override SolImp"
        doc = """Replaces the solimp parameter of all active contact pairs when
        Contact override is enabled."""
    )
    uniform double[] mjc:option:o_solref = [0.02, 1] (
        displayName = "Contact Override SolRef"
        doc = """Replaces the solref parameter of all active contact pairs when
        Contact override is enabled."""
    )
    uniform int mjc:option:sdf_initpoints = 40 (
        displayName = "SDF Initial Points"
        doc = """Number of starting points used for finding contacts with Signed
        Distance Field collisions."""
    )
    uniform int mjc:option:sdf_iterations = 10 (
        displayName = "SDF Iterations"
        doc = """Number of iterations used for Signed Distance Field collisions
        (per initial point)."""
    )
    uniform token mjc:option:solver = "newton" (
        allowedTokens = ["pgs", "cg", "newton"]
        displayName = "Solver"
        doc = "Constraint solver algorithm to be used."
    )
    uniform double mjc:option:timestep = 0.002 (
        displayName = "Timestep"
        doc = "Controls the timestep in seconds used by MuJoCo."
    )
    uniform double mjc:option:tolerance = 1e-8 (
        displayName = "Solver Tolerance"
        doc = """Tolerance threshold used for early termination of the iterative
        solver."""
    )
    uniform double mjc:option:viscosity = 0 (
        displayName = "Viscosity"
        doc = "Viscosity of medium."
    )
    uniform double3 mjc:option:wind = (0, 0, 0) (
        displayName = "Wind Velocity"
        doc = "Velocity vector of medium (i.e. wind)."
    )
}

class "SiteAPI" (
    doc = "API describing a Mujoco site."
)
{
}

class "CollisionAPI" (
    doc = "API describing a Mujoco collider."
)
{
    uniform bool mjc:shellinertia = 0 (
        displayName = "Shell Inertia"
        doc = "Enables handling of the inertia assuming mass is concentrated on the surface."
    )
}

class "MeshCollisionAPI" (
    doc = "API describing a Mujoco collider."
)
{
    uniform token mjc:inertia = "legacy" (
        allowedTokens = ["legacy", "convex", "exact", "shell"]
        displayName = "Inertia"
        doc = "Controls how a mesh is used when mass and inertia are inferred from geometry."
    )
}

class "PhysicsActuatorAPI" (
    doc = "API describing a Mujoco actuator."
)
{
    uniform int mjc:actDim = -1 (
        doc = "Dimension of the activation state. The default value of -1 instructs the compiler to set the dimension according to the dyntype. Values larger than 1 are only allowed for user-defined activation dynamics, as native types require dimensions of only 0 or 1. For activation dimensions bigger than 1, the last element is used to generate force."
    )
    uniform bool mjc:actEarly = 0 (
        doc = "If true, force computation will use the next value of the activation variable rather than the current one. Setting this flag reduces the delay between the control and accelerations by one time-step."
    )
    uniform token mjc:actLimited = "auto" (
        allowedTokens = ["false", "true", "auto"]
        doc = "If true, the internal state (activation) associated with this actuator is automatically clamped to actrange at runtime. If false, activation clamping is disabled. If 'auto' and autolimits is set in compiler, activation clamping will automatically be set to true if actrange is defined without explicitly setting this attribute to 'true'. See the Activation clamping section for more details."
    )
    uniform double mjc:actRange:max = 0 (
        doc = "Maximum range for clamping the activation state. The first value must be no greater than the second value. See the Activation clamping section for more details. Setting this attribute without specifying actlimited is an error if autolimits is 'false' in compiler."
    )
    uniform double mjc:actRange:min = 0 (
        doc = "Minimum range for clamping the activation state. The first value must be no greater than the second value. See the Activation clamping section for more details. Setting this attribute without specifying actlimited is an error if autolimits is 'false' in compiler."
    )
    uniform double[] mjc:biasPrm = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] (
        doc = "Bias parameters. The affine bias type uses three parameters. The length of this array is not enforced by the parser, so the user can enter as many parameters as needed. These defaults are not compatible with muscle actuators."
    )
    uniform token mjc:biasType = "none" (
        allowedTokens = ["none", "affine", "muscle", "user"]
        doc = "The gain and bias together determine the output of the force generation mechanism, which is currently assumed to be affine."
    )
    uniform double mjc:crankLength = 0 (
        doc = "Used only for the slider-crank transmission type. Specifies the length of the connecting rod. The compiler expects this value to be positive when a slider-crank transmission is present."
    )
    uniform token mjc:ctrlLimited = "auto" (
        allowedTokens = ["false", "true", "auto"]
        doc = "If true, the control input to this actuator is automatically clamped to ctrlrange at runtime. If false, control input clamping is disabled. If 'auto' and autolimits is set in compiler, control clamping will automatically be set to true if ctrlrange is defined without explicitly setting this attribute to 'true'. Note that control input clamping can also be globally disabled with the clampctrl attribute of option/flag."
    )
    uniform double mjc:ctrlRange:max = 0 (
        doc = "Maximum range for clamping the control input. The first value must be smaller than the second value. Setting this attribute without specifying ctrllimited is an error if autolimits is 'false' in compiler."
    )
    uniform double mjc:ctrlRange:min = 0 (
        doc = "Minimum range for clamping the control input. The first value must be smaller than the second value. Setting this attribute without specifying ctrllimited is an error if autolimits is 'false' in compiler."
    )
    uniform double[] mjc:dynPrm = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] (
        doc = "Activation dynamics parameters. The built-in activation types (except for muscle) use only the first parameter, but we provide additional parameters in case user callbacks implement a more elaborate model. The length of this array is not enforced by the parser, so the user can enter as many parameters as needed. These defaults are not compatible with muscle actuators."
    )
    uniform token mjc:dynType = "none" (
        allowedTokens = ["none", "integrator", "filter", "filterexact", "muscle", "user"]
        doc = "Activation dynamics type for the actuator. The available dynamics types were already described in the Actuation model section."
    )
    uniform token mjc:forceLimited = "auto" (
        allowedTokens = ["false", "true", "auto"]
        doc = "If true, the force output of this actuator is automatically clamped to forcerange at runtime. If false, force clamping is disabled. If 'auto' and autolimits is set in compiler, force clamping will automatically be set to true if forcerange is defined without explicitly setting this attribute to 'true'."
    )
    uniform double mjc:forceRange:max = 0 (
        doc = "Maximum range for clamping the force output. The first value must be no greater than the second value. Setting this attribute without specifying forcelimited is an error if autolimits is 'false' in compiler."
    )
    uniform double mjc:forceRange:min = 0 (
        doc = "Minimum range for clamping the force output. The first value must be no greater than the second value. Setting this attribute without specifying forcelimited is an error if autolimits is 'false' in compiler."
    )
    uniform double[] mjc:gainPrm = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] (
        doc = "Gain parameters. The built-in gain types (except for muscle) use only the first parameter, but we provide additional parameters in case user callbacks implement a more elaborate model. The length of this array is not enforced by the parser, so the user can enter as many parameters as needed. These defaults are not compatible with muscle actuators."
    )
    uniform token mjc:gainType = "fixed" (
        allowedTokens = ["fixed", "affine", "muscle", "user"]
        doc = "The gain and bias together determine the output of the force generation mechanism, which is currently assumed to be affine."
    )
    uniform double[] mjc:gear = [1, 0, 0, 0, 0, 0] (
        doc = "This attribute scales the length (and consequently moment arms, velocity and force) of the actuator, for all transmission types. It is different from the gain in the force generation mechanism, because the gain only scales the force output and does not affect the length, moment arms and velocity. For actuators with scalar transmission, only the first element of this vector is used. The remaining elements are needed for joint, jointinparent and site transmissions where this attribute is used to specify 3D force and torque axes."
    )
    uniform bool mjc:jointInParent = 0 (
        doc = "If true and applied to ball and free joints, the 3d rotation axis given by gear is defined in the parent frame (which is the world frame for free joints) rather than the child frame."
    )
    uniform double mjc:lengthRange:max = 0 (
        doc = "Maximum range of feasible lengths of the actuator’s transmission."
    )
    uniform double mjc:lengthRange:min = 0 (
        doc = "Minimum range of feasible lengths of the actuator’s transmission."
    )
    rel mjc:refSite (
        doc = "When applied to a site, measure the translation and rotation w.r.t the frame of the refsite. In this case the actuator does have length and position actuators can be used to directly control an end effector, see refsite.xml example model. As above, the length is the dot product of the gear vector and the frame difference. So gear='0 1 0 0 0 0' means 'Y-offset of site in the refsite frame', while gear='0 0 0 0 0 1' means rotation 'Z- rotation of site in the refsite frame'. It is recommended to use a normalized gear vector with nonzeros in only the first 3 or the last 3 elements of gear, so the actuator length will be in either length units or radians, respectively. As with ball joints (see joint above), for rotations which exceed a total angle of pi will wrap around, so tighter limits are recommended."
    )
    rel mjc:sliderSite (
        doc = "Used only for the slider-crank transmission type. The target site is the pin joining the slider and the connecting rod. The slider moves along the z-axis of the slidersite frame. Therefore the site should be oriented as needed when it is defined in the kinematic tree; its orientation cannot be changed in the actuator definition."
    )
}

class Keyframe "Keyframe" (
    doc = "Represents time independent keyframe values."
)
{
    double[] mjc:act (
        doc = "Vector of actuator activations, copied into mjData.act when the simulation state is set to this keyframe."
    )
    double[] mjc:ctrl (
        doc = "Vector of controls, copied into mjData.ctrl when the simulation state is set to this keyframe."
    )
    double[] mjc:mpos (
        doc = "Vector of mocap body positions, copied into mjData.mocap_pos when the simulation state is set to this keyframe."
    )
    double[] mjc:mquat (
        doc = "Vector of mocap body quaternions, copied into mjData.mocap_quat when the simulation state is set to this keyframe."
    )
    double[] mjc:qpos (
        doc = "Vector of joint positions, copied into mjData.qpos when the simulation state is set to this keyframe."
    )
    double[] mjc:qvel (
        doc = "Vector of joint velocities, copied into mjData.qvel when the simulation state is set to this keyframe."
    )
}

class "PhysicsJointsAPI" (
    doc = "API describing a Mujoco joint."
)
{
    uniform token mjc:actuatorfrclimited = "auto" (
        allowedTokens = ["false", "true", "auto"]
        doc = "This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. This attribute interacts with the actuatorfrcrange attribute. If this attribute is 'false', actuator force clamping is disabled. If it is 'true', actuator force clamping is enabled. If this attribute is 'auto', and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined."
    )
    uniform double mjc:actuatorfrcrange:max = 0 (
        doc = "Maximum range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. The compiler expects the first value to be smaller than the second value. Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is 'false'."
    )
    uniform double mjc:actuatorfrcrange:min = 0 (
        doc = "Minimum range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. The compiler expects the first value to be smaller than the second value. Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is 'false'."
    )
    uniform bool mjc:actuatorgravcomp = 0 (
        doc = "If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit."
    )
    uniform double mjc:armature = 0 (
        doc = "Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. The value applies to all degrees of freedom created by this joint. Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues."
    )
    uniform double mjc:damping = 0 (
        doc = "Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter."
    )
    uniform double mjc:frictionloss = 0 (
        doc = "Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value."
    )
    uniform double mjc:margin = 0 (
        doc = "The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit."
    )
    uniform double mjc:ref = 0 (
        doc = "The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors was discussed in the Stand-alone section in the Overview chapter."
    )
    uniform double[] mjc:solimpfriction = [0.9, 0.95, 0.001, 0.5, 2] (
        doc = "Constraint solver parameters for simulating dry friction."
    )
    uniform double[] mjc:solimplimit = [0.9, 0.95, 0.001, 0.5, 2] (
        doc = "Constraint solver parameters for simulating joint limits."
    )
    uniform double[] mjc:solreffriction = [0.02, 1] (
        doc = "Constraint solver parameters for simulating dry friction."
    )
    uniform double[] mjc:solreflimit = [0.02, 1] (
        doc = "Constraint solver parameters for simulating joint limits."
    )
    uniform double[] mjc:springdamper = [0, 0] (
        doc = "When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver."
    )
    uniform double mjc:springref = 0 (
        doc = "The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs."
    )
    uniform double mjc:stiffness = 0 (
        doc = "Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces."
    )
}

