#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class "MjcSceneAPI" (
    doc = "API providing global simulation options for MuJoCo."
)
{
    uniform bool mjc:compiler:alignFree = 0 (
        displayName = "Align Free"
        doc = "This attribute toggles the default behaviour of an optimization that applies to bodies with a free joint and no child bodies. When True, the body frame and free joint will automatically be aligned with inertial frame, which leads to both faster and more stable simulation."
    )
    uniform token mjc:compiler:angle = "degree" (
        allowedTokens = ["degree", "radian"]
        displayName = "Angle"
        doc = "This attribute specifies whether the angles in mjcPhysics attributes have units of degrees or radians if not otherwise noted."
    )
    uniform bool mjc:compiler:autoLimits = 1 (
        displayName = "Automatic Limits"
        doc = 'This attribute affects the behavior of attributes such as "limited" (on MjcJointAPI), "forcelimited" "ctrllimited", and "actlimited" (on MjcActuator). If True, these attributes are unnecessary and their value will be inferred from the presence of their corresponding "range" attribute. If False, no such inference will happen: For a joint to be limited, both limited=True and range:min/max must be specified. In this mode, it is an error to specify a range without a limit.'
    )
    uniform bool mjc:compiler:balanceInertia = 0 (
        displayName = "Balance Inertia"
        doc = 'A valid diagonal inertia matrix must satisfy A+B>=C for all permutations of the three diagonal elements. Some poorly designed models violate this constraint, which will normally result in a compile error. If this attribute is set to "true", the compiler will silently set all three diagonal elements to their average value whenever the above condition is violated.'
    )
    uniform double mjc:compiler:boundInertia = 0 (
        displayName = "Bound Inertia"
        doc = "This attribute imposes a lower bound on the diagonal inertia components of each body except for the world body."
    )
    uniform double mjc:compiler:boundMass = 0 (
        displayName = "Bound Mass"
        doc = "This attribute imposes a lower bound on the mass of each body except for the world body."
    )
    uniform bool mjc:compiler:fitAABB = 0 (
        displayName = "Fit AABB"
        doc = "The compiler is able to replace a mesh with a geometric primitive fitted to that mesh. If this attribute is True, the fitting procedure uses the axis-aligned bounding box (AABB) of the mesh. Otherwise it uses the equivalent-inertia box of the mesh."
    )
    uniform bool mjc:compiler:fuseStatic = 0 (
        displayName = "Fuse Static"
        doc = """This attribute controls a compiler optimization feature where static bodies are fused with their parent, and any elements defined in those bodies are reassigned to the parent. Static bodies are fused with their parent unless

* They are referenced by another element in the model.

* They contain a site which is referenced by a force or torque sensor.
"""
    )
    uniform token mjc:compiler:inertiaFromGeom = "auto" (
        allowedTokens = ["false", "true", "auto"]
        displayName = "Inertia From Geom"
        doc = 'This attribute controls the automatic inference of body masses and inertias from geoms attached to the body. If this setting is "false", no automatic inference is performed. In that case each body must have explicitly defined mass and inertia with the inertial element, or else a compile error will be generated. If this setting is "true", the mass and inertia of each body will be inferred from the geoms attached to it, overriding any values specified with the inertial element. The default setting "auto" means that masses and inertias are inferred automatically only when the inertial element is missing in the body definition. One reason to set this attribute to "true" instead of "auto" is to override inertial data imported from a poorly designed model.'
    )
    uniform int mjc:compiler:inertiaGroupRange:max = 5 (
        displayName = "Inertia Group Range Max"
        doc = "This attribute specifies the maximum of the geom group range that is used to infer body masses and inertias (when such inference is enabled). The group attribute of geom is an integer. If this integer falls in the range specified here, the geom will be used in the inertial computation, otherwise it will be ignored. This feature is useful in models that have redundant sets of geoms for collision and visualization. Note that the world body does not participate in the inertial computations, so any geoms attached to it are automatically ignored. Therefore it is not necessary to adjust this attribute and the geom-specific groups so as to exclude world geoms from the inertial computation."
    )
    uniform int mjc:compiler:inertiaGroupRange:min = 0 (
        displayName = "Inertia Group Range Min"
        doc = "This attribute specifies the maximum of the geom group range that is used to infer body masses and inertias (when such inference is enabled). The group attribute of geom is an integer. If this integer falls in the range specified here, the collider will be used in the inertial computation, otherwise it will be ignored. Note that the world body does not participate in the inertial computations, so any geoms attached to it are automatically ignored. Therefore it is not necessary to adjust this attribute and the geom-specific groups so as to exclude world geoms from the inertial computation."
    )
    uniform bool mjc:compiler:saveInertial = 0 (
        displayName = "Save Inertial"
        doc = "If True, the compiler will save explicit inertial clauses for all bodies."
    )
    uniform double mjc:compiler:setTotalMass = -1 (
        displayName = "Set Total Mass"
        doc = "If this value is positive, the compiler will scale the masses and inertias of all bodies in the model, so that the total mass equals the value specified here. The world body has mass 0 and does not participate in any mass-related computations. This scaling is performed last, after all other operations affecting the body mass and inertia. The same scaling operation can be applied at runtime to the compiled mjModel with the function mj_setTotalmass."
    )
    uniform bool mjc:compiler:useThread = 1 (
        displayName = "Use Thread"
        doc = "If this is True, the model compiler will run in multi-threaded mode. Currently multi-threading is used for computing the length ranges of actuators and for parallel loading of meshes."
    )
    uniform bool mjc:flag:actuation = 1 (
        displayName = "Actuation Forces Toggle"
        doc = "Enables all standard computations related to actuator forces, including actuator dynamics."
    )
    uniform bool mjc:flag:autoreset = 1 (
        displayName = "Automatic Simulation Reset Toggle"
        doc = "Enables the automatic resetting of the simulation state when numerical issues are detected."
    )
    uniform bool mjc:flag:clampctrl = 1 (
        displayName = "Control Input Clamping Toggle"
        doc = "Enables the clamping of control inputs to all actuators, according to actuator-specific attributes."
    )
    uniform bool mjc:flag:constraint = 1 (
        displayName = "Constraint Solver Toggle"
        doc = "Enables constraint solver."
    )
    uniform bool mjc:flag:contact = 1 (
        displayName = "Contact Constraints and Collision Detection Toggle"
        doc = "Enables collision detection and all standard computations related to contact constraints."
    )
    uniform bool mjc:flag:damper = 1 (
        displayName = "Damper Forces Toggle"
        doc = "Enables the simulation of joint and tendon dampers."
    )
    uniform bool mjc:flag:energy = 0 (
        displayName = "Energy Computation Toggle"
        doc = "Enables the computation of potential and kinetic energy (mjData.energy[0,1])."
    )
    uniform bool mjc:flag:equality = 1 (
        displayName = "Equality Constraints Toggle"
        doc = "Enables all standard computations related to equality constraints."
    )
    uniform bool mjc:flag:eulerdamp = 1 (
        displayName = "Euler Integrator Damping Toggle"
        doc = "Enables implicit integration with respect to joint damping in the Euler integrator."
    )
    uniform bool mjc:flag:filterparent = 1 (
        displayName = "Parent-Child Contact Filtering Toggle"
        doc = "Enables the filtering of contact pairs where the two geoms belong to a parent and child body."
    )
    uniform bool mjc:flag:frictionloss = 1 (
        displayName = "Friction Loss Constraints Toggle"
        doc = "Enables all standard computations related to friction loss constraints."
    )
    uniform bool mjc:flag:fwdinv = 0 (
        displayName = "Forward/Inverse Dynamics Comparison Toggle"
        doc = "Enables the automatic comparison of forward and inverse dynamics."
    )
    uniform bool mjc:flag:gravity = 1 (
        displayName = "Gravity Toggle"
        doc = "Enables the application of gravitational acceleration as defined in mjOption."
    )
    uniform bool mjc:flag:invdiscrete = 0 (
        displayName = "Discrete-Time Inverse Dynamics Toggle"
        doc = "Enables discrete-time inverse dynamics with mj_inverse for integrators other than RK4."
    )
    uniform bool mjc:flag:island = 1 (
        displayName = "Constraint Island Discovery Toggle"
        doc = "Enables the discovery of constraint islands."
    )
    uniform bool mjc:flag:limit = 1 (
        displayName = "Joint and Tendon Limit Constraints Toggle"
        doc = "Enables all standard computations related to joint and tendon limit constraints."
    )
    uniform bool mjc:flag:midphase = 1 (
        displayName = "Mid-Phase Collision Filtering Toggle"
        doc = "Enables mid-phase collision filtering using a static AABB bounding volume hierarchy (BVH)."
    )
    uniform bool mjc:flag:multiccd = 0 (
        displayName = "Multiple Contact Collision Detection (CCD) Toggle"
        doc = "Enables multiple-contact collision detection for geom pairs using a general-purpose convex-convex collider."
    )
    uniform bool mjc:flag:nativeccd = 1 (
        displayName = "Native Convex Collision Detection Toggle"
        doc = "Enables the native convex collision detection pipeline instead of using the libccd library."
    )
    uniform bool mjc:flag:override = 0 (
        displayName = "Contact Override Mechanism Toggle"
        doc = "Enables the contact override mechanism."
    )
    uniform bool mjc:flag:refsafe = 1 (
        displayName = "Solver Reference Safety Mechanism Toggle"
        doc = "Enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep."
    )
    uniform bool mjc:flag:sensor = 1 (
        displayName = "Sensor Computations Toggle"
        doc = "Enables all computations related to sensors."
    )
    uniform bool mjc:flag:spring = 1 (
        displayName = "Spring Forces Toggle"
        doc = "Enables the simulation of joint and tendon springs."
    )
    uniform bool mjc:flag:warmstart = 1 (
        displayName = "Solver Warm-Starting Toggle"
        doc = "Enables warm-starting of the constraint solver, using the solution from the previous time step to initialize the iterative optimization."
    )
    uniform int[] mjc:option:actuatorgroupdisable = [] (
        displayName = "Actuator Group Disable"
        doc = "List of actuator groups to disable."
    )
    uniform int mjc:option:ccd_iterations = 35 (
        displayName = "CCD Iterations"
        doc = "Maximum number of iterations of the algorithm used for convex collisions."
    )
    uniform double mjc:option:ccd_tolerance = 0.000001 (
        displayName = "CCD Tolerance"
        doc = """Tolerance threshold used for early termination of the convex
        collision algorithm."""
    )
    uniform token mjc:option:cone = "pyramidal" (
        allowedTokens = ["pyramidal", "elliptic"]
        displayName = "Friction Cone Type"
        doc = "The type of contact friction cone."
    )
    uniform double mjc:option:density = 0 (
        displayName = "Density"
        doc = "Density of medium."
    )
    uniform double mjc:option:impratio = 1 (
        displayName = "Impedance Ratio"
        doc = """Ratio of frictional-to-normal constraint impedance for elliptic
        friction cones."""
    )
    uniform token mjc:option:integrator = "euler" (
        allowedTokens = ["euler", "rk4", "implicit", "implicitfast"]
        displayName = "Integrator"
        doc = "Numerical integrator to be used."
    )
    uniform int mjc:option:iterations = 100 (
        displayName = "Solver Iterations"
        doc = "Maximum number of iterations of the constraint solver."
    )
    uniform token mjc:option:jacobian = "auto" (
        allowedTokens = ["auto", "dense", "sparse"]
        displayName = "Jacobian Type"
        doc = "The type of constraint Jacobian and matrices computed from it."
    )
    uniform int mjc:option:ls_iterations = 50 (
        displayName = "Linesearch Iterations"
        doc = """Maximum number of linesearch iterations performed by CG/Newton
        constraint solvers."""
    )
    uniform double mjc:option:ls_tolerance = 0.01 (
        displayName = "Linesearch Tolerance"
        doc = "Tolerance threshold used for early termination of the linesearch algorithm."
    )
    uniform double3 mjc:option:magnetic = (0, -0.5, 0) (
        displayName = "Magnetic Flux"
        doc = "Global magnetic flux."
    )
    uniform int mjc:option:noslip_iterations = 0 (
        displayName = "Noslip Iterations"
        doc = "Maximum number of iterations of the Noslip solver."
    )
    uniform double mjc:option:noslip_tolerance = 0.000001 (
        displayName = "Noslip Tolerance"
        doc = "Tolerance threshold used for early termination of the Noslip solver."
    )
    uniform double[] mjc:option:o_friction = [1, 1, 0.005, 0.0001, 0.0001] (
        displayName = "Contact Override Friction"
        doc = """Replaces the friction parameter of all active contact pairs when
        Contact override is enabled."""
    )
    uniform double mjc:option:o_margin = 0 (
        displayName = "Contact Override Margin"
        doc = """Replaces the margin parameter of all active contact pairs when
        Contact override is enabled."""
    )
    uniform double[] mjc:option:o_solimp = [0.9, 0.95, 0.001, 0.5, 2] (
        displayName = "Contact Override SolImp"
        doc = """Replaces the solimp parameter of all active contact pairs when
        Contact override is enabled."""
    )
    uniform double[] mjc:option:o_solref = [0.02, 1] (
        displayName = "Contact Override SolRef"
        doc = """Replaces the solref parameter of all active contact pairs when
        Contact override is enabled."""
    )
    uniform int mjc:option:sdf_initpoints = 40 (
        displayName = "SDF Initial Points"
        doc = """Number of starting points used for finding contacts with Signed
        Distance Field collisions."""
    )
    uniform int mjc:option:sdf_iterations = 10 (
        displayName = "SDF Iterations"
        doc = """Number of iterations used for Signed Distance Field collisions
        (per initial point)."""
    )
    uniform token mjc:option:solver = "newton" (
        allowedTokens = ["pgs", "cg", "newton"]
        displayName = "Solver"
        doc = "Constraint solver algorithm to be used."
    )
    uniform double mjc:option:timestep = 0.002 (
        displayName = "Timestep"
        doc = "Controls the timestep in seconds used by MuJoCo."
    )
    uniform double mjc:option:tolerance = 1e-8 (
        displayName = "Solver Tolerance"
        doc = """Tolerance threshold used for early termination of the iterative
        solver."""
    )
    uniform double mjc:option:viscosity = 0 (
        displayName = "Viscosity"
        doc = "Viscosity of medium."
    )
    uniform double3 mjc:option:wind = (0, 0, 0) (
        displayName = "Wind Velocity"
        doc = "Velocity vector of medium (i.e. wind)."
    )
}

class "MjcSiteAPI" (
    doc = "API describing a MuJoCo site."
)
{
    uniform int mjc:group = 0 (
        displayName = "Group"
        doc = "Integer MuJoCo group to which the collider belongs."
    )
}

class "MjcImageableAPI" (
    doc = "API describing attributes for visual entities in MuJoCo."
)
{
    uniform int mjc:group = 0 (
        displayName = "Group"
        doc = "Integer MuJoCo group to which the imageable belongs."
    )
}

class "MjcCollisionAPI" (
    doc = "API describing a MuJoCo collider."
)
{
    uniform int mjc:condim = 3 (
        displayName = "ConDim"
        doc = "The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms."
    )
    uniform double mjc:gap = 0 (
        displayName = "Gap"
        doc = "This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts."
    )
    uniform int mjc:group = 0 (
        displayName = "Group"
        doc = "Integer MuJoCo group to which the collider belongs."
    )
    uniform double mjc:margin = 0 (
        displayName = "Margin"
        doc = "Distance threshold below which contacts are detected and included in the global array mjData.contact."
    )
    uniform int mjc:priority = 0 (
        displayName = "Priority"
        doc = "Priority determining how the properties of two colliders are combined to form the properties of the contact."
    )
    uniform bool mjc:shellinertia = 0 (
        displayName = "Shell Inertia"
        doc = "Enables handling of the inertia assuming mass is concentrated on the surface."
    )
    uniform double[] mjc:solimp = [0.9, 0.95, 0.001, 0.5, 2] (
        displayName = "SolImp"
        doc = "Specifies the weight used for averaging of contact parameters, and interacts with the priority attribute."
    )
    uniform double mjc:solmix = 1 (
        displayName = "SolMix"
        doc = "Specifies the weight used for averaging of contact parameters, and interacts with the priority attribute."
    )
    uniform double[] mjc:solref = [0.02, 1] (
        displayName = "SolMix"
        doc = "Specifies the weight used for averaging of contact parameters, and interacts with the priority attribute."
    )
}

class "MjcMeshCollisionAPI" (
    doc = "API describing a MuJoCo mesh collider."
)
{
    uniform token mjc:inertia = "legacy" (
        allowedTokens = ["legacy", "convex", "exact", "shell"]
        displayName = "Inertia"
        doc = "Controls how a mesh is used when mass and inertia are inferred from geometry."
    )
    uniform int mjc:maxhullvert = -1 (
        displayName = "Maximum Hull Vertices"
        doc = "Sets an upper limit on the number of vertices in the meshes convex hull. The default value of -1 means unlimited."
    )
}

class MjcActuator "MjcActuator" (
    doc = "Known as actuator in MuJoCo, this prim represents force transmission to joints, bodies, or sites."
)
{
    uniform int mjc:actDim = -1 (
        doc = "Dimension of the activation state. The default value of -1 instructs the compiler to set the dimension according to the dyntype. Values larger than 1 are only allowed for user-defined activation dynamics, as native types require dimensions of only 0 or 1. For activation dimensions bigger than 1, the last element is used to generate force."
    )
    uniform bool mjc:actEarly = 0 (
        doc = "If true, force computation will use the next value of the activation variable rather than the current one. Setting this flag reduces the delay between the control and accelerations by one time-step."
    )
    uniform token mjc:actLimited = "auto" (
        allowedTokens = ["false", "true", "auto"]
        doc = "If true, the internal state (activation) associated with this actuator is automatically clamped to actrange at runtime. If false, activation clamping is disabled. If 'auto' and autolimits is set in compiler, activation clamping will automatically be set to true if actrange is defined without explicitly setting this attribute to 'true'. See the Activation clamping section for more details."
    )
    uniform double mjc:actRange:max = 0 (
        doc = "Maximum range for clamping the activation state. The first value must be no greater than the second value. See the Activation clamping section for more details. Setting this attribute without specifying actlimited is an error if autolimits is 'false' in compiler."
    )
    uniform double mjc:actRange:min = 0 (
        doc = "Minimum range for clamping the activation state. The first value must be no greater than the second value. See the Activation clamping section for more details. Setting this attribute without specifying actlimited is an error if autolimits is 'false' in compiler."
    )
    uniform double[] mjc:biasPrm = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] (
        doc = "Bias parameters. The affine bias type uses three parameters. The length of this array is not enforced by the parser, so the user can enter as many parameters as needed. These defaults are not compatible with muscle actuators."
    )
    uniform token mjc:biasType = "none" (
        allowedTokens = ["none", "affine", "muscle", "user"]
        doc = "The gain and bias together determine the output of the force generation mechanism, which is currently assumed to be affine."
    )
    uniform double mjc:crankLength = 0 (
        doc = "Used only for the slider-crank transmission type. Specifies the length of the connecting rod. The compiler expects this value to be positive when a slider-crank transmission is present."
    )
    uniform token mjc:ctrlLimited = "auto" (
        allowedTokens = ["false", "true", "auto"]
        doc = "If true, the control input to this actuator is automatically clamped to ctrlrange at runtime. If false, control input clamping is disabled. If 'auto' and autolimits is set in compiler, control clamping will automatically be set to true if ctrlrange is defined without explicitly setting this attribute to 'true'. Note that control input clamping can also be globally disabled with the clampctrl attribute of option/flag."
    )
    uniform double mjc:ctrlRange:max = 0 (
        doc = "Maximum range for clamping the control input. The first value must be smaller than the second value. Setting this attribute without specifying ctrllimited is an error if autolimits is 'false' in compiler."
    )
    uniform double mjc:ctrlRange:min = 0 (
        doc = "Minimum range for clamping the control input. The first value must be smaller than the second value. Setting this attribute without specifying ctrllimited is an error if autolimits is 'false' in compiler."
    )
    uniform double[] mjc:dynPrm = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] (
        doc = "Activation dynamics parameters. The built-in activation types (except for muscle) use only the first parameter, but we provide additional parameters in case user callbacks implement a more elaborate model. The length of this array is not enforced by the parser, so the user can enter as many parameters as needed. These defaults are not compatible with muscle actuators."
    )
    uniform token mjc:dynType = "none" (
        allowedTokens = ["none", "integrator", "filter", "filterexact", "muscle", "user"]
        doc = "Activation dynamics type for the actuator. The available dynamics types were already described in the Actuation model section."
    )
    uniform token mjc:forceLimited = "auto" (
        allowedTokens = ["false", "true", "auto"]
        doc = "If true, the force output of this actuator is automatically clamped to forcerange at runtime. If false, force clamping is disabled. If 'auto' and autolimits is set in compiler, force clamping will automatically be set to true if forcerange is defined without explicitly setting this attribute to 'true'."
    )
    uniform double mjc:forceRange:max = 0 (
        doc = "Maximum range for clamping the force output. The first value must be no greater than the second value. Setting this attribute without specifying forcelimited is an error if autolimits is 'false' in compiler."
    )
    uniform double mjc:forceRange:min = 0 (
        doc = "Minimum range for clamping the force output. The first value must be no greater than the second value. Setting this attribute without specifying forcelimited is an error if autolimits is 'false' in compiler."
    )
    uniform double[] mjc:gainPrm = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] (
        doc = "Gain parameters. The built-in gain types (except for muscle) use only the first parameter, but we provide additional parameters in case user callbacks implement a more elaborate model. The length of this array is not enforced by the parser, so the user can enter as many parameters as needed. These defaults are not compatible with muscle actuators."
    )
    uniform token mjc:gainType = "fixed" (
        allowedTokens = ["fixed", "affine", "muscle", "user"]
        doc = "The gain and bias together determine the output of the force generation mechanism, which is currently assumed to be affine."
    )
    uniform double[] mjc:gear = [1, 0, 0, 0, 0, 0] (
        doc = "This attribute scales the length (and consequently moment arms, velocity and force) of the actuator, for all transmission types. It is different from the gain in the force generation mechanism, because the gain only scales the force output and does not affect the length, moment arms and velocity. For actuators with scalar transmission, only the first element of this vector is used. The remaining elements are needed for joint, jointinparent and site transmissions where this attribute is used to specify 3D force and torque axes."
    )
    uniform int mjc:group = 0 (
        displayName = "Group"
        doc = "Integer MuJoCo group to which the transmission belongs."
    )
    uniform double mjc:inheritRange = 0 (
        doc = "Automatically set the actuator’s ctrlrange to match the transmission target’s range. The default value means disabled. A positive value X sets the ctrlrange around the midpoint of the target range, scaled by X. For example if the target joint has range of [0, 1], then a value of 1.0 will set ctrlrange to [0, 1]; values of 0.8 and 1.2 will set the ctrlrange to [0.1, 0.9] and [-0.1, 1.1], respectively. Values smaller than 1 are useful for not hitting the limits; values larger than 1 are useful for maintaining control authority at the limits (being able to push on them). This attribute is exclusive with ctrlrange and available only for joint and tendon transmissions which have range defined."
    )
    uniform bool mjc:jointInParent = 0 (
        doc = "If true and applied to ball and free joints, the 3d rotation axis given by gear is defined in the parent frame (which is the world frame for free joints) rather than the child frame."
    )
    uniform double mjc:lengthRange:max = 0 (
        doc = "Maximum range of feasible lengths of the actuator's transmission."
    )
    uniform double mjc:lengthRange:min = 0 (
        doc = "Minimum range of feasible lengths of the actuator's transmission."
    )
    rel mjc:refSite (
        doc = "When applied to a site, measure the translation and rotation w.r.t the frame of the refsite. In this case the actuator does have length and position actuators can be used to directly control an end effector, see refsite.xml example model. As above, the length is the dot product of the gear vector and the frame difference. So gear='0 1 0 0 0 0' means 'Y-offset of site in the refsite frame', while gear='0 0 0 0 0 1' means rotation 'Z- rotation of site in the refsite frame'. It is recommended to use a normalized gear vector with nonzeros in only the first 3 or the last 3 elements of gear, so the actuator length will be in either length units or radians, respectively. As with ball joints (see joint above), for rotations which exceed a total angle of pi will wrap around, so tighter limits are recommended."
    )
    rel mjc:sliderSite (
        doc = "Used only for the slider-crank transmission type. The target site is the pin joining the slider and the connecting rod. The slider moves along the z-axis of the slidersite frame. Therefore the site should be oriented as needed when it is defined in the kinematic tree; its orientation cannot be changed in the actuator definition."
    )
    rel mjc:target (
        doc = "Actuator transmission target."
    )
}

class MjcKeyframe "MjcKeyframe" (
    doc = "Represents time independent keyframe values."
)
{
    double[] mjc:act (
        doc = "Vector of actuator activations, copied into mjData.act when the simulation state is set to this keyframe."
    )
    double[] mjc:ctrl (
        doc = "Vector of controls, copied into mjData.ctrl when the simulation state is set to this keyframe."
    )
    double[] mjc:mpos (
        doc = "Vector of mocap body positions, copied into mjData.mocap_pos when the simulation state is set to this keyframe."
    )
    double[] mjc:mquat (
        doc = "Vector of mocap body quaternions, copied into mjData.mocap_quat when the simulation state is set to this keyframe."
    )
    double[] mjc:qpos (
        doc = "Vector of joint positions, copied into mjData.qpos when the simulation state is set to this keyframe."
    )
    double[] mjc:qvel (
        doc = "Vector of joint velocities, copied into mjData.qvel when the simulation state is set to this keyframe."
    )
}

class "MjcJointAPI" (
    doc = "API describing a MuJoCo joint."
)
{
    uniform token mjc:actuatorfrclimited = "auto" (
        allowedTokens = ["false", "true", "auto"]
        doc = "This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. This attribute interacts with the actuatorfrcrange attribute. If this attribute is 'false', actuator force clamping is disabled. If it is 'true', actuator force clamping is enabled. If this attribute is 'auto', and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined."
    )
    uniform double mjc:actuatorfrcrange:max = 0 (
        doc = "Maximum range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. The compiler expects the first value to be smaller than the second value. Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is 'false'."
    )
    uniform double mjc:actuatorfrcrange:min = 0 (
        doc = "Minimum range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. The compiler expects the first value to be smaller than the second value. Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is 'false'."
    )
    uniform bool mjc:actuatorgravcomp = 0 (
        doc = "If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit."
    )
    uniform double mjc:armature = 0 (
        doc = "Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. The value applies to all degrees of freedom created by this joint. Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues."
    )
    uniform double mjc:damping = 0 (
        doc = "Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter."
    )
    uniform double mjc:frictionloss = 0 (
        doc = "Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value."
    )
    uniform int mjc:group = 0 (
        displayName = "Group"
        doc = "Integer MuJoCo group to which the joint belongs."
    )
    uniform double mjc:margin = 0 (
        doc = "The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit."
    )
    uniform double mjc:ref = 0 (
        doc = "The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors was discussed in the Stand-alone section in the Overview chapter."
    )
    uniform double[] mjc:solimpfriction = [0.9, 0.95, 0.001, 0.5, 2] (
        doc = "Constraint solver parameters for simulating dry friction."
    )
    uniform double[] mjc:solimplimit = [0.9, 0.95, 0.001, 0.5, 2] (
        doc = "Constraint solver parameters for simulating joint limits."
    )
    uniform double[] mjc:solreffriction = [0.02, 1] (
        doc = "Constraint solver parameters for simulating dry friction."
    )
    uniform double[] mjc:solreflimit = [0.02, 1] (
        doc = "Constraint solver parameters for simulating joint limits."
    )
    uniform double[] mjc:springdamper = [0, 0] (
        doc = "When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver."
    )
    uniform double mjc:springref = 0 (
        doc = "The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs."
    )
    uniform double mjc:stiffness = 0 (
        doc = "Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces."
    )
}

class "MjcMaterialAPI" (
    doc = "API providing extension attributes to represent physical MuJoCo materials."
)
{
    uniform double mjc:rollingfriction = 0.0001 (
        displayName = "Rolling Friction"
        doc = "Friction value acting around both axes on the contact tangent plane."
    )
    uniform double mjc:torsionalfriction = 0.005 (
        displayName = "Torsional Friction"
        doc = "Friction value acting around contact normal."
    )
}

